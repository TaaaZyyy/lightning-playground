LDS
## 主な原則
CSSを書くことなく、SalesforceUIに準拠したデザインを使用できる。
### バンドル
- CSSフレームワーク
    - ページヘッダ、ラベル、フォーム、グリッドレイアウトシステム、ヘルパークラス
- アイコン
- フォント
- デザイントークン
### 4つの開発思想
1. 透明性: ユーザが必要な情報を簡単に見つけられること。
2. 効率性: ワークフローの合理化と最適化。行動を促す。
3. 一貫性
4. 美しさ
### 使用可能箇所
- Visualforce: ただし現段階では `<apex>` との互換性はない。
- Lightningコンポーネント
- Mobile SDK
- スタンドアロンWebアプリケーション（Heroku上のなど）

## 使い始める



## グリッドシステムの理解
行と列
ネストできる
SalesforceのグリッドシステムはCSS Flexboxがベース
ブレークポイントは480px, 768px and 1024pxで設定

グリッドシステムは、グリッドラッパー（slds-gridクラスで指定）とその中のカラム（slds-colクラスで指定）の2つの主要なビルディングブロックに基づいています。ここに例があります：

<div class="slds-grid">
  <div class="slds-col">Column 1</div>
  <div class="slds-col">Column 2</div>
  <div class="slds-col">Column 3</div>
</div>

自動でサイジングされる。手動の場合は、
slds-size-X-of-Y形式を使用します（Xは総スペースYの一部を表します）

<!-- BASIC GRID EXAMPLE -->
<div class="slds-grid">
  <div class="slds-col slds-size--4-of-6">Column 1</div>
  <div class="slds-col slds-size--1-of-6">Column 2</div>
  <div class="slds-col slds-size--1-of-6">Column 3</div>
</div>

画面サイズによってグリッドレイアウトを変更することが可能
mobile small medium large

<!-- RESPONSIVE GRID EXAMPLE -->
<div class="slds-grid slds-wrap">
  <div class="slds-col slds-size--1-of-1 slds-small-size--1-of-2 slds-medium-size--3-of-4">A</div>
  <div class="slds-col slds-size--1-of-1 slds-small-size--1-of-2 slds-medium-size--1-of-4">B</div>
</div>

リストページの作成
- 適切に配置されたトップヘッダー
- メインリスエリア
- ベースフッター

## Salesforceデータの操作
## 画像、アイコン、アバターの使用
## レコードページをレイアウトし、高度なコンポーネントを使用する




## aura:component の implements
- flexipage:availableForRecordHome
- force:hasRecordId

## aura:applecation の extends
- force:slds
















# 目次
- 概要
    - 一言で言うと
    - 学習の際の注意点
- 用語
- 実装準備
    - 開発ツール
    - デバッグ
    - Lightningコンポーネント開発準備
- 実装

# Lightningコンポーネント
## 概要
### 一言で言うと
動的なWebアプリケーションを開発するためのUIフレームワーク。
サーバー側ではApex、クライアント側ではJavascriptで動く。
カプセル化されたコンポーネントを組み合わせる（コンポジション）ことで迅速な開発を可能にする。
Lightning コンポーネントを使ったアプリケーション構築の基本概念の一部:
コンポーネントをアクションハンドラに接続することを「結び付けること」




Lightning コンポーネントは自己完結型であることが求められます。これらは、すべての必須機能をカプセル化するスタンドアロン要素です。コンポーネントは、別のコンポーネントに (子コンポーネントにさえ) アクセスして内部を変更することはできません

<lightning:button> の onclick 属性をコンポーネントのコントローラのアクションハンドラに設定したら、これら 2 つのコンポーネントの間に直接リレーションを作成します。それらはリンクされ、公開 API が使用され相互の独立が維持されている間でも連動します。

コンポーネントはイベントを別のコンポーネントに送信しません。これはイベントの機能ではありません。コンポーネントは特定の種別のイベントをブロードキャストします。イベントの種別に対応するコンポーネントがあり、そのコンポーネントがイベントを「受信する」場合、イベントに基づいて動作します。

属性とイベントの違いは有線回路と無線の違いと考えることができます。


コンポーネントは他のコンポーネントにアクセスして値を設定することはできません。
コンポーネントは上位コンポーネントで何かの変更を行う場合、イベントを適切に送信して依頼します。

ただし、やがてわかりますが、新しい経費を作成するコードと既存の経費を更新するコードは、コードの重複を避けたくなるほど非常に似ています。このため、行った設計選択は、主要な expenses コンポーネントによって処理される updateExpense イベントを送信
→ コードの重複をなくすため、イベントの送信を選択する？


重要なロジックの統合またはカプセル化を選択できます。ソフトウェア設計のトレードオフを行うのと同様に、Lightning コンポーネントでトレードオフを行います。詳細をドキュメント化するようにします。

イベント処理に進む前に、イベント送信に必要なことをまとめましょう。

Lightning イベントを作成し、名前と属性を指定して、カスタムイベントを定義します。
カスタムイベント種別を選択し、その種別の特定使用に名前を指定して、これらのイベントを送信するコンポーネントを登録します。
次を行い、コントローラ (またはヘルパー) のコードでイベントを起動します。
component.getEvent() を使用した、特定のイベントインスタンスの作成。
fire() を使用したイベントの送信。

Lightning イベントは何に使用されますか?
疎結合のコンポーネント間の通信




### 学習の際の注意点
Lightning コンポーネントフレームワークは Visualforce よりも大規模であり、洗練され、複雑です。
それほど機能的でない Lightning コンポーネントアプリケーションを記述する場合でさえ、JavaScript に精通している必要があります。
他言語と比較してjavascriptは学習する必要がある十分な違いが存在します。たとえば、オブジェクトと継承、範囲ルール、真と偽を分ける予測不能な動作などです。
Visualforce コードを Lightning コンポーネント形式で記述しない。Lightning コンポーネントの優れたコードの設計とアーキテクチャは、Visualforce の優れたコードとは別物です。
- javascriptは大文字と小文字が区別される（Apex、Visualforceと異なる）
- javascriptは静的リソース以外の場所のものを読み込めない
- IE11はCSPをサポートしないため、LockerServiceが無効化される。セキュリティに問題が出てくる。



## 用語
### コンポーネント（バンドル）
LightningコンポーネントによるWebアプリケーションの構成単位。
インスタンスとして利用できるため、再利用性高い。
HTML、CSS、javascript

### コンポーネント

### イベント
インターフェースイベント発生時に対応するハンドラを作成する。

### Lightning 基本コンポーネント

### Field Service Lightning
### Lightning Design System
cssフレームワーク。Salesforceの提供サービスが利用しているデザインを利用できる。商用可。
積極的に使う。独自のCSSスタイルは最終手段的に限定された特別なケースでのみ使用。
#### 注意点
SLDS コンポーネントは Lightning コンポーネントではありません。Lightning 組み込みコンポーネントの中で必要なものが見つからない場合、自分でコンポーネントを作成するための開始点として SLDS サイトを使用します。（SLDS は、Salesforce が目指している未来の世界を表します。）


### Lightningデータサービス
XHR の減少
コンポーネント間でのレコードデータの共有
ローカルのオフラインキャッシュ

コンポーネントを読み込むときに force:recordData を使用してレコードを読み込む場合、どの属性が必要ですか?


DS の最も簡単な使用方法の 1 つとして、レコードの読み込みがあります。クライアント側でレコードを読み込むには、force:recordData タグをコンポーネントに追加して、recordId、mode、および layoutType または fields 属性を設定する必要があります。

layoutType には、レコードの表示に使用するレイアウト (FULL または COMPACT) を指定します。
fields には、レコードのどの項目をクエリするかを指定します。fields または layoutType 属性 (あるいはその両方) を指定する必要があります。


## 実装準備
### Lightningコンポーネント開発準備
1. カスタムSalesforceドメイン名を定義していること。
2. Lightningコンポーネントプレビュー用のハーネスアプリケーション（Lightningコンポーネントをラップする開発用のLightningアプリケーション）
    アクセス: '/c/harnessApp.app'

## 実装
### 設計手順
アプリケーションをコンポーネントに分解する。
最初に最も小さく、最も内側のコンポーネントから作成していく。

### コントローラ（Apex）
状態を格納できない。
ナビゲーションロジックは実装できない（PageReferenceを返せない）。
- public クラス
- @AuraEnabled public static メソッド
- 仮引数名はクライアント側でアクションを作成するときに使用するパラメータ名と一致させることが強く推奨される。
- サーバ側のメソッド名とクライアント側のアクションハンドラの関数名は同じにしないことが強く推奨される。

### コントローラ（javascript）
名前:値ペアの対応付けが含まれる JSON オブジェクトです。アクションハンドラ（匿名関数）のみを含めることができます。
引数は、component、event、helperをとる。
c.とv.でやり取りできるのはコンポネントの.cmpとコントローラの.js間のみ。
#### コンポーネントのプロパティにアクセスする方法
componentのgetメソッドとsetメソッドを使用する

```
component.get("v.プロパティ名");
component.set("v.プロパティ名", 値);
```

#### イベントが発生したタグの情報にアクセスする方法
eventのgetSourceメソッドを使用する

```
<lightning:button label="this is label" onclick="{!c.hanleClick}/>

handleClick : function(component, event, helper) {
    var btnClicked = event.getSource();
    var btnMessage = btnClicked.get("v.label");
}
```

#### idを指定してformタグの情報にアクセスする
componentのfindメソッドを使用する
子コンポーネントにアクセスする方法がコントローラで必要であるときは、最初にそのコンポーネントのマークアップで aura:id を設定し、component.find(theId) を使用して実行時にコンポーネントの参照を取得します。

```
var validExpense = component.find('expenseform').reduce(function (validSoFar, inputCmp) {...
```

### ヘルパー
アクションハンドラー（コントローラのメソッド）間で再利用する関数を配置する。
任意の引数を取れるが、慣例として最初の引数はヘルパーを呼び出すコンポーネントの参照。
ヘルパーはシングルトンで、すべてのコンポーネントインスタンスで共有される（cf.静的メソッド）。
ヘルパーには関数以外を追加できます。また、一度だけ読み込まれる API ログイン情報などの値をコントローラアクションハンドラに提供することもできます。ただし、これは共有変数で、不正なアクセスを防ぐものがない、ということを覚えておく必要があります。この方法は、よく考えてから使用してください。

### コントローラとヘルパー
アクションハンドラはできるだけシンプルで分かりやすくするのがベストプラクティスだと考え、詳細情報をヘルパーに抽出する人が多くいます。これはこれで良識的な方法ですが、他にも方法はあります。
複数のアクションハンドラで再利用するコードはヘルパーに入れることをお勧めします。それ以外は、各自の好みとスタイル、組織のコーディング基準に従って決めてください。

### 式と値プロパイダ
#### v.プロパティ名
v.は表示の値プロバイダで、そのものがコンポーネントです。コンポーネントの属性を参照するには、この方法を使用します。
値プロパイダは省略できない。
#### （コンポーネント内）c.アクション名
c.はコントローラ（javascript）の値プロパイダ。関数を呼び出すのに使う。
#### （コントローラ内）c.
c.はコントローラ（Apex）の値プロパイダ。
#### 式
.cmp、.appでのみ使用する。
式を使用すると、コンポーネントのマークアップ内で計算することや、プロパティ値やその他のデータにアクセスすることができます。式は、動的出力や、値を属性に割り当ててコンポーネントに渡す場合に使用します。
三項演算子使用可能
#### バインド式
その値が使用されているすべての場所の間で双方向バインドを作成し、Lightning コンポーネントに魔法のように作用します。ある箇所で値を変更すると、その値がすべての場所で変更されます。

```
{! v.messageText }
```

#### 非バインド式

```
{# v.messageText }
```

## Lightning Design System
Lightning Experience または Salesforce アプリケーションでコンポーネントを実行するとき、コンポーネントで SLDS が自動的に使用可能になります。one.app コンテナで動作している SLDS をコールすることがあります。この組み込みバージョンは、多くの標準 Lightning コンポーネントによって使用されるものと同じです。ただし、スタンドアロンアプリケーションでは SLDS はデフォルトで使用可能にならず、Visualforce の Lightning Out または Lightning コンポーネントでコンポーネントを使用するときにも、SLDS は使用可能になりません。
### 使用方法1
0. aura:componentタグに ``` extends="force:slds" ```を加える
1. https://www.lightningdesignsystem.com/ から使用したいコンポネントを見つける
2. 使用箇所にコメントでLDSを使用する旨を記載する（保守開発を用意にするため）

```
<!--
    Lightning Design System の data table を使用する
    https://www.lightningdesignsystem.com/components/data-tables/
-->
```

3. コードをコピペする
4. 目的に合わせてクラスを変更する
5. 目的に合わせてコードを修正する

## デバッグ
コードのどの行で失敗しているのかをすばやく見つけるには、コードを実行する前に [Pause on all exceptions (すべての例外で一時停止)] オプションを有効にします。
ツール
- [Chrome DevTools](https://developers.google.com/web/tools/chrome-devtools/)
- [Salesforce Lightning Inspector](https://developer.salesforce.com/docs/atlas.ja-jp.210.0.lightning.meta/lightning/inspector_intro.htm)
### ログ出力
変数に何が含まれているかが分かるような詳細情報が入ったログがあるだけで解決の糸口になることもあります。

```
console.log('someVariable: ' + JSON.stringify(someVariable));
```

### Salesforce Lightning Inspector
[Salesforce Lightning Inspector](https://developer.salesforce.com/docs/atlas.ja-jp.210.0.lightning.meta/lightning/inspector_use.htm)
コンポーネント間のやりとりを診断するとき => [Event Log (イベントログ)] タブ
サーバ要求の問題を診断するとき => [Actions (アクション)] タブ
[イベント処理のライフサイクル](https://developer.salesforce.com/docs/atlas.ja-jp.210.0.lightning.meta/lightning/events_overview.htm)について、もっと学ぶ必要もあるかもしれません。

### デバッグモード
デバッグモードが有効になっていることを確認してください。デバッグモードを有効にすると、ダウンロードされた JavaScript が縮小されるのを回避できます。または、高度なデバッグ作業に必要な詳細情報を簡単に取得できるようになります。デバッグ作業でコードのトレースが必要な場合は、必ずデバッグモードを有効にしてください。有効にしないと、コードを判読できません。

# 実装のヒント
## 継承とコンポジション
Lightningコンポネントは親コンポネントを継承できる。
しかし、継承よりもコンポジションを優先させる。
- フレームワークの実装で継承を使用するとパフォーマンスに大きく影響する。
- Lightningコンポーネントの継承の動作は気まぐれ。親関数の書換えはできるが拡張はできない。
- フレームワークの仕様が変わるおそれがあるため、複雑な継承階層は使用すべきでない。

## ApexとLightningコンポネント
### Apex は JavaScript ではない
Apex から JavaScript にデータを返すときに 変換 - 逐次化 - 送信 - 並列化 というプロセスを経る。
データをパッケージ化して Lightning コンポーネントに返すための専用の Apex クラスを作成すると若干複雑さが減り、デバッグも容易になる。
### sObject
JavaScript コードで、カスタムオブジェクトを含む新しい sObject を作成することができます。少しだけ長くなりますが、分かりやすい構文です。これらの sObject は、要求時にパラメータとしてサーバ側 Apex に送信できます。Apex からの応答に sObject を返すことができ、変換はフレームワークによって行われます。
### カスタムクラス
#### javascript => Apex
通常、カスタムの Apex クラスをクライアント側 JavaScript からサーバ側 Apex にパラメータとして渡すことはできません。この場合はプレーンな JavaScript オブジェクトを使用して、パラメータの構造化データをカプセル化します。必要に応じて、たとえば Apex クラスのコンストラクタなどの Apex コードで、そのオブジェクトを解析します。
#### Apex => javascript
カスタム Apex クラスは、サーバ側コントローラから応答としてクライアント側 JavaScript に返すことができます。ただし、カスタム Apex クラスはそのプロセスの一部として逐次化・並列化されるため、予想とは異なる結果になることがあります。 含めたいデータ要素や自分で作成した JSON と一緒にマップを返す方が良いことが多いです。
### 内部クラス
 Apex 内部クラスは Lightning コンポーネントコードでは使用できません。サーバ側 Apex コードでは、要求の処理時に内部クラスを使用することができますが、クライアントに返される応答を内部クラスのインスタンスにすることはできません。
### 継承
 Lightning コンポーネントへの応答で返す予定のカスタム Apex クラスに継承を使用することはできません。
### サーバ側エラーの処理
 Apex コードでエラーが発生した場合、AuraHandledException を作成して発生させることができます。DML 例外などの他の例外をキャッチして、AuraHandledException として再発生させても、クライアント側での操作性が大幅に向上します。

 ```
 throw new AuraHandledException('HOGE HOGE.')
 ```




# 未整理


Elementオブジェクト
Componentオブジェクト
Eventオブジェクト

component.set("attributName", value);
let Elementオブジェクト = event.getSource();
let 値 = Elementオブジェクト.get("v.属性名);





## expensesアプリケーションコンポーネント
## Expensesの新規フォーム
## sObjectの属性
## アクションハンドラでのフォーム登録の処理
## 新規経費の作成
## 参照はコレクションではない
## 経費のリストの表示


attributeにはSObject型を取れる。defaultはJSONで表現する。

```
<aura:attribute name="newExpense" type="Expense__c"
    default="{'sobjectType': 'Expense__c',
              'Name': '',
              'Amount__c': 0,
              'Client__c': '',
              'Date__c': '',
              'Reimbursed__c': false}"/>
```

<lightning:card title="{!v.expense.Name}" iconName="standard:scan_card"
            class="{!v.expense.Reimbursed__c ? 'slds-theme_success' : ''}">




## 名前空間
組織に名前空間プレフィックスが設定されている場合は、その名前空間を使用してLightningコンポーネント、
イベント、カスタムオブジェクト、カスタム項目、および Lightning マークアップのその他の項目を参照しま
す。
次の項目は、組織に名前空間プレフィックスが設定されている場合、組織の名前空間を使用します。
• 作成したコンポーネントへの参照
• 定義したイベントへの参照
• カスタムオブジェクトへの参照
• 標準オブジェクトおよびカスタムオブジェクトのカスタム項目への参照
• Apex コントローラへの参照
• 静的リソースへの参照

名前空間プレフィックスを登録して、組織の名前空間を作成します。
配布用の管理パッケージを作成しない場合は、名前空間プレフィックスを登録する必要はありませんが、ごく
小規模な組織を除き、どの組織にとっても登録することがベストプラクティスです。


1. [設定] から、[クイック検索] ボックスに「パッケージ」と入力します。[作成] で[パッケージ]を選択します。
メモ: この項目は、Salesforce Classic でのみ使用できます。
2. [開発者設定] パネルで、[編集] をクリックします。
メモ: すでに開発者設定が定義されている場合は、このボタンは表示されません。
3. 開発者設定に必要な選択項目を確認し、[続行] をクリックします。
4. 登録する名前空間プレフィックスを入力します。
5. [使用可能か調べる] をクリックして、名前空間プレフィックスが使用済みかどうかを確認します。
6. 入力した名前空間プレフィックスを使用できない場合は、上記の 2 つの手順を繰り返します。
7. [選択内容の確認] をクリックします。
8. [保存] をクリックします。



スタイル
ドキュメント
レンダラ
設計
SVG

最後に、Visualforce のアプリ内コンポーネントリファレンスと同じように、組織にインストールしたコンポーネントの動的リファレンスとして、https://<yourDomain>.lightning.force.com/auradocs/reference.app にあるリファレンスドキュメントアプリケーションを見てみてください。


```
<aura:component controller="AccountsController">
    <aura:attribute name="accounts" action="{!c.doInit}"/>
    <aura:handler name="init" value="{!this}" action="{!c.doInit}"/>
</aura:component>

```


### aura名前空間
アプリケーションロジックを簡略化するコンポーネント
### ui名前空間
ボタン、入力項目などユーザインターフェース
### force名前空間
Salesforce固有のコンポーネント




たとえば、one.app コンテナ (Lightning Experience と Salesforce アプリケーション) では、レコードに移動する、レコードを作成または編集する、URL を開くといった、イベントの処理がサービスとして提供されます。
他のコンテナではこれらのサービスは提供されません。あるコンテナのサービスに依存するコンポーネントは、そのサービスが提供されない別のコンテナでは機能しません。たとえば、新規レコードの作成に force:createRecord イベントを使用すると、Lightning Experience では適切に機能しますが、そのコンポーネントをスタンドアロンアプリケーションや Lightning Out 内で使用すると、イベントを処理するものがないため、動作が停止します
ここが重要な部分です。Lightning コンポーネントコードは、それを内部で実行するコンテナのサービスのみにアクセスできます。そのコンテナが別のコンテナの内部にある場合も同じです。




ヘルパーはシングルトンであり、コンポーネントのすべてのインスタンスで共有されます。


コントローラ JavaScript コードで属性値を取得および設定するには get メソッドと setメソッドを使用します。



コンポーネントの属性の値を他のコンポーネントが操作できないようにするには、属性を private にします。そうしない場合は、属性がコンポーネントの公開 API の一部になります。
非公開属性の名前には、プレフィックスとしてアンダースコアを使用して (_myAttribute など)、非公開属性であることを明確にするとよいでしょう)


expando は軽微なバグやメモリーリークにつながる場合があるということです。うまく機能すると思われる一方で、問題が発生する可能性も捨てきれません。そのため、Salesorce では expando の使用はお勧めしません。










Lightning コンポーネントフレームワークは、Visualforce のこれらの制限事項に対処するように設計されました。特に、コンポーネントは (意図的に) 疎結合されています。この疎結合のメカニズムがイベントです。








Lightning コンポーネントコントローラのコードはクライアント側で実行されますが、データはサーバ側に保存されます。キャッシュがない場合、新しいデータが必要になるたびに何らかのサーバ要求を行うことになります。それはおそらく、Visualforce コントローラであれば記述することがなかったコードです。
